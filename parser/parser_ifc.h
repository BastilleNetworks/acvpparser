/*
 * Copyright (C) 2020 - 2024, Stephan Mueller <smueller@chronox.de>
 *
 * License: see LICENSE file in root directory
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
 * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

#ifndef PARSER_IFC_H
#define PARSER_IFC_H

#ifdef __cplusplus
extern "C"
{
#endif

/**
 * @brief SP800-56B rev 2 KTS IFC data structure for the initiator algorithm
 *	  functional test (AFT) - a form of known-answer test.
 *
 * @var n [in] The ACVP server's RSA N (modulus) parameter
 * @var e [in] The ACVP server's RSA e (public exponent) parameter
 * @var iut_n [in] The IUT's RSA N (modulus) parameter (only set for KAS2)
 * @var iut_e [in] The IUT's RSA e (public exponent) parameter  (only set for
 * 		   KAS2)
 * @var iut_p [in] The IUT's RSA p parameter - may be NULL (only set for KAS2)
 * @var iut_q [in] The IUT's RSA q parameter - may be NULL (only set for KAS2)
 * @var iut_d [in] The IUT's RSA d (private exponent) parameter (only set for
 * 		   KAS2)
 * @var iut_dmp1 [in] The IUT's RSA dmp1 parameter (only set for KAS2 and if
 * 		      key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iut_dmq1 [in] The IUT's RSA dmq1 parameter (only set for KAS2 and if
 * 		      key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iut_iqmp [in] The IUT's RSA iqmp parameter (only set for KAS2 and if
 * 		      key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var server_c [in] The ciphertext computed by the ACVP server (using the
 * 		      IUT's public key) (only set for KAS2)
 * @var iut_c [out] The ciphertext computed by the IUT (using the ACVP server's
 *		    public key)
 * @var dkm [out] The derived keying material as a result of the KTS/KAS
 * @var tag [out] The key confirmation resulting MAC tag from the perspective
 *		  of the IUT
 */
struct kts_ifc_init_data {
	struct buffer n;
	struct buffer e;
	struct buffer iut_n;
	struct buffer iut_e;
	struct buffer iut_p;
	struct buffer iut_q;
	struct buffer iut_d;
	struct buffer iut_dmp1;
	struct buffer iut_dmq1;
	struct buffer iut_iqmp;
	struct buffer server_c;

	struct buffer iut_c;
	struct buffer dkm;
	struct buffer tag;
};

/**
 * @brief SP800-56B rev 2 KTS IFC data structure for the initiator validation
 *	  testing (VAL). The IUT should verify the provided data and return
 *	  the status whether the KTS/KAS negotiation would have succeeded.
 *
 * @var n [in] The ACVP server's RSA N (modulus) parameter
 * @var e [in] The ACVP server's RSA e (public exponent) parameter
 * @var p [in] The ACVP server's RSA p parameter - may be NULL
 * @var q [in] The ACVP server's RSA q parameter - may be NULL
 * @var iut_n [in] The IUT's RSA N (modulus) parameter (only set for KAS2)
 * @var iut_e [in] The IUT's RSA e (public exponent) parameter  (only set for
 * 		   KAS2)
 * @var iut_p [in] The IUT's RSA p parameter - may be NULL (only set for KAS2)
 * @var iut_q [in] The IUT's RSA q parameter - may be NULL (only set for KAS2)
 * @var iut_d [in] The IUT's RSA d (private exponent) parameter (only set for
 * 		   KAS2)
 * @var iut_dmp1 [in] The IUT's RSA dmp1 parameter (only set for KAS2 and if
 * 		      key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iut_dmq1 [in] The IUT's RSA dmq1 parameter (only set for KAS2 and if
 * 		      key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iut_iqmp [in] The IUT's RSA iqmp parameter (only set for KAS2 and if
 * 		      key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var c [in] The ciphertext generated by the IUT, encrypted with the ACVP
 *	       server's public key
 * @var server_c [in] The ciphertext generated by the ACVP server, encrypted
 * 		      with the IUT's public key (only set for KAS2)
 * @var dkm [in] The derived keying material to be validated
 * @val validation_success [out] The KTS/KAS negotiation has succeeded (1) or
 * 				 not succeeded (0)
 */
struct kts_ifc_init_validation_data {
	struct buffer n;
	struct buffer e;
	struct buffer p;
	struct buffer q;
	struct buffer iut_n;
	struct buffer iut_e;
	struct buffer iut_p;
	struct buffer iut_q;
	struct buffer iut_d;
	struct buffer iut_dmp1;
	struct buffer iut_dmq1;
	struct buffer iut_iqmp;
	struct buffer c;
	struct buffer server_c;
	struct buffer dkm;

	uint32_t validation_success;
};

/**
 * @brief SP800-56B rev 2 KTS data structure for the responder algorithm
 *	  functional test (AFT) - a form of known-answer test.
 *
 * @var server_n [in] The ACVP server's RSA N (modulus) parameter (only set for
 * 		      KAS2)
 * @var server_e [in] The ACVP server's RSA e (public exponent) parameter (only
 * 		      set for KAS2)
 * @var n [in] The IUT's RSA N (modulus) parameter
 * @var e [in] The IUT's RSA e (public exponent) parameter
 * @var p [in] The IUT's RSA p parameter
 * @var q [in] The IUT's RSA q parameter
 * @var d [in] The IUT's RSA d (private exponent) parameter
 * @var dmp1 [in] The IUT's RSA dmp1 parameter (only set if
 * 		  key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var dmq1 [in] The IUT's RSA dmq1 parameter (only set if
 * 		  key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iqmp [in] The IUT's RSA iqmp parameter (only set if
 * 		  key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var c [in] The ciphertext generated by the ACVP server, encrypted with the
 *	       IUT's public key
 * @var iut_c [out] The ciphertext generated by the IUT, encrypted with the ACVP
 *		    server's public key (only required for KAS2)
 * @var dkm [out] The derived keying material as a result of the KTS/KAS
 * @var tag [out] The key confirmation resulting MAC tag from the perspective
 *		  of the IUT
 */
struct kts_ifc_resp_data {
	struct buffer server_n;
	struct buffer server_e;
	struct buffer n;
	struct buffer e;
	struct buffer p;
	struct buffer q;
	struct buffer d;
	struct buffer dmp1;
	struct buffer dmq1;
	struct buffer iqmp;
	struct buffer c;

	struct buffer iut_c;
	struct buffer dkm;
	struct buffer tag;
};

/**
 * @brief SP800-56B rev 2 KTS data structure for the responder validation
 *	  testing (VAL). The IUT should verify the provided data and return
 *	  the status whether the KTS/KAS negotiation would have succeeded.
 *
 * @var server_n [in] The ACVP server's RSA N (modulus) parameter (only set for
 * 		      KAS2)
 * @var server_e [in] The ACVP server's RSA e (public exponent) parameter (only
 * 		      set for KAS2)
 * @var server_p [in] The ACVP server's RSA p parameter (only set for KAS2)
 * @var server_q [in] The ACVP server's RSA q parameter (only set for KAS2)
 * @var n [in] The IUT's RSA N (modulus) parameter
 * @var e [in] The IUT's RSA e (public exponent) parameter
 * @var p [in] The IUT's RSA p parameter
 * @var q [in] The IUT's RSA q parameter
 * @var d [in] The IUT's RSA d (private exponent) parameter
 * @var dmp1 [in] The IUT's RSA dmp1 parameter (only set if
 * 		  key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var dmq1 [in] The IUT's RSA dmq1 parameter (only set if
 * 		  key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iqmp [in] The IUT's RSA iqmp parameter (only set if
 * 		  key_generation_method is ACVP_KAS_KEYGEN_*_CRT)
 * @var iut_c [in] The ciphertext generated by the IUT, encrypted with the ACVP
 *		   server's public key (only set for KAS2)
 * @var c [in] The ciphertext generated by the ACVP server, encrypted with the
 *	       IUT's public key
 * @var dkm [in] The derived keying material (or the shared secret Z) as a
 *		 result of the KTS negotiation
 * @var dkm_hash [in] Hashed version of the derived keying material / shared
 *		      secret (this is an optional field)
 * @val validation_success [out] The KTS/KAS negotiation has succeeded (1) or
 * 				 not succeeded (0)
 */
struct kts_ifc_resp_validation_data {
	struct buffer server_n;
	struct buffer server_e;
	struct buffer server_p;
	struct buffer server_q;
	struct buffer n;
	struct buffer e;
	struct buffer p;
	struct buffer q;
	struct buffer d;
	struct buffer dmp1;
	struct buffer dmq1;
	struct buffer iqmp;
	struct buffer iut_c;
	struct buffer c;
	struct buffer dkm;
	struct buffer dkm_hash;

	uint32_t validation_success;
};

/**
 * @brief SP800-56B rev 2 KTS data structure holding the common test definition.
 *	  All options except for the union are applicable to the KTS IFC
 *	  testing.
 *
 * The union defined in this data structure fills the test-specific data. The
 * backend knows the type of testing and thus the data structure from the union
 * based on the following check:
 *
 *	if ((parsed_flags & FLAG_OP_KAS_ROLE_INITIATOR) &&
 *	    (parsed_flags & FLAG_OP_AFT)) {
 *		struct kts_ifc_init_data *init = &data->u.kts_ifc_init;
 *
 *		// KTS IFC initiator AFT testing
 *
 *	} else if ((parsed_flags & FLAG_OP_KAS_ROLE_RESPONDER) &&
 *		   (parsed_flags & FLAG_OP_AFT)) {
 *		struct kts_ifc_resp_data *resp = &data->u.kts_ifc_resp;
 *
 *		// KTS IFC responder AFT testing
 *
 *	} else if ((parsed_flags & FLAG_OP_KAS_ROLE_INITIATOR) &&
 *		   (parsed_flags & FLAG_OP_VAL)) {
 *		struct kts_ifc_init_validation_data *init_val =
 *					&data->u.kts_ifc_init_validation;
 *
 *		// KTS IFC initiator VAL testing
 *
 *	} else if ((parsed_flags & FLAG_OP_KAS_ROLE_RESPONDER) &&
 *		   (parsed_flags & FLAG_OP_VAL)) {
 *		struct kts_ifc_resp_validation_data *resp_val =
 *					&data->u.kts_ifc_resp_validation;
 *
 *		// KTS IFC responder VAL testing
 *
 *	} else {
 *		logger(LOGGER_ERR, "Unknown test\n");
 *		ret = -EINVAL;
 *	}
 *
 * @val schema [in] The scheme in use for the testing (ACVP_KTS_SCHEMA* or
 *	ACVP_KAS1_SCHEMA_* or ACVP_KAS2_SCHEMA_*)
 * @val key_generation_method [in] The private key generation method
 *	(ACVP_KAS_KEYGEN_*)
 * @val modulus [in] RSA modulus in use for key generation in bits
 * @val keylen [in] The length of key to derive / transport in bits. If this
 *	value is zero (e.g. for KAS_IFC_SSC), the key length shall be identical
 *	to the modulus as there is no KTS/MAC support to truncate the data.
 * @val iut_id [in] The IUT's identifier. This is NULL when no KTS is applied
 *	(i.e. KAS_IFC_SSC).
 * @val server_id [in] The server's identifier. This is NULL when no KTS is
 *	applied (i.e. KAS_IFC_SSC).
 *
 * @val kts_hash [in] KTS configuration: The hash algorithm used for the OAEP
 *	function
 *
 * TODO kts_assoc_data_pattern WILL change in the future pending issue #800
 * @val kts_assoc_data_pattern [in] The pattern used for constructing the
 *	associated data - currently the string as documented in the KAS IFC
 *	specification section 3.4.1.4 is held here. This value may be NULL if
 *	no associated data is to be processed.
 *
 * @val kts_encoding [in] The encoding type used when constructing the
 * 	associated data (ACVP_KAS_ENCODING_*).
 *
 * @val mac [in] The MAC type used in key confirmation.
 * @val mac_keylen [in] The number of bits to take from the derived keying
 *	material to use for as the MAC key in key confirmation.
 * @val mac_maclen [in] The number of bits to use for the MAC tag.
 *
 * @val u [in] Union of data structures where the relevant data structure is
 *	filled as outlined above.
 *
 * NOTE: If the KTS configuration is found, the test MUST perform an RSA OAEP
 *	 operation. If the KTS configuration is not found, the test MUST
 *	 perform a raw RSA operation without padding.
 */
struct kts_ifc_data {
	uint64_t schema;
	uint64_t key_generation_method;
	uint32_t modulus;
	uint32_t keylen;
	struct buffer iut_id;
	struct buffer server_id;

	/* KTS configuration */
	uint64_t kts_hash;
	struct buffer kts_assoc_data_pattern;
	uint64_t kts_encoding;

	/* MAC configuration */
	uint64_t mac;
	uint32_t mac_keylen;
	uint32_t mac_maclen;

	union {
		struct kts_ifc_init_data kts_ifc_init;
		struct kts_ifc_init_validation_data kts_ifc_init_validation;
		struct kts_ifc_resp_data kts_ifc_resp;
		struct kts_ifc_resp_validation_data kts_ifc_resp_validation;
	} u;
};

/**
 * @brief Callback data structure that must be implemented by the backend.
 *
 * All functions return 0 on success or != 0 on error.
 *
 * @val kts_ifc Perform KTS IFC testing
 */
struct kts_ifc_backend {
	int (*kts_ifc)(struct kts_ifc_data *data,  flags_t parsed_flags);
};

void register_kts_ifc_impl(struct kts_ifc_backend *implementation);

#ifdef __cplusplus
}
#endif

#endif /* PARSER_IFC_H */
